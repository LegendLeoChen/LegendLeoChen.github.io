<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个秘密空间" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>大模型基础知识 |  LegendLeo Chen 的空间</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/mylogo.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
<!-- 封面标闪烁 -->
<link rel="stylesheet" href="/css/zhyBlogTitle.css">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!-- jquery，懒加载、统计、说说需要的jquery -->
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-大模型基础知识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  大模型基础知识
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2024-12-27T08:09:30.000Z" itemprop="datePublished">2024-12-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">27 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="🔥大语言模型（LLMs）是什么"><a href="#🔥大语言模型（LLMs）是什么" class="headerlink" title="🔥大语言模型（LLMs）是什么"></a>🔥大语言模型（LLMs）是什么</h1><p>大模型：一般指1亿以上参数的模型，但是这个标准一直在升级，目前万亿参数以上的模型 (eg: MinMax abab6.5)也有了。大语言模型(Large Language Models，LLMs) 是针对语言的大模型。<br>大语言模型的关键特点包括:<span id="more"></span></p>
<ol>
<li><strong>大规模参数</strong>：LLMs拥有大量参数(如GPT-3的175B或PaLM的540B),参数数量越多，模型对语言的捕捉能力越强，可以更好地理解上下文和生成流畅的语言。</li>
<li><strong>多任务处理能力</strong>：经过训练后，LMS具备在多种语言任务上表现良好的能力，例如文本摘要、情感分析、机器翻译等。这是因为它们学会了在大数据集上归纳出各种语言模式和规律。</li>
<li><strong>上下文理解</strong>：LLM5可以根据上下文生成有逻辑和连贯的回应，这使得它们特别适合对话和内容创作任务。模型可以“记住”一段对话中的重要细节，并在后续对话中保持一致性。</li>
<li><strong>自监督学习</strong>：大语言模型主要依赖自监督学习，使用未标注的数据进行训练，通过预测下一个词、填补空白或匹配句子等方式来学习语言结构。</li>
<li><strong>通用性和可扩展性</strong>：LLMs可以迁移到多种任务和领域，经过少量微调就能在专门的任务(如医学文本分析或法律文件摘要)中发挥作用。</li>
</ol>
<p>尽管大语言模型在许多任务上表现出色，但它们也有一些局限性，比如生成错误信息、偏见问题以及需要高昂的计算资源。</p>
<h1 id="🔥大语言模型按预训练任务分类："><a href="#🔥大语言模型按预训练任务分类：" class="headerlink" title="🔥大语言模型按预训练任务分类："></a>🔥大语言模型按预训练任务分类：</h1><ul>
<li>自回归语言模型：GPT为代表，仅通过前文预测下一个词，适合生成任务。</li>
<li>自编码语言模型：BERT为代表，通过掩码预测被遮挡的词，适合理解和任务分类。</li>
<li>序列到序列语言模型：如T5、BART等，既可以生成文本也可以完成理解任务，在机器翻译、文本生成场景中有广泛应用。</li>
</ul>
<h1 id="🔥主流的LLMs开源模型体系"><a href="#🔥主流的LLMs开源模型体系" class="headerlink" title="🔥主流的LLMs开源模型体系"></a>🔥主流的LLMs开源模型体系</h1><p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%B8%BB%E6%B5%81LLMs%E5%BC%80%E6%BA%90%E6%A8%A1%E5%9E%8B%E4%BD%93%E7%B3%BB.jpg" alt="主流LLMs开源模型体系"></p>
<ul>
<li>Encoder-Decoder：<ul>
<li>经典结构，编码器端用<strong>双向自注意力</strong>进行编码，在解码器用<strong>交叉注意力</strong>与<strong>单向注意力掩码</strong>机制，通过<strong>自回归</strong>方式进行生成。编码器内，前面的token也能知道后面的token，而解码器中token不能知道其前面的token。</li>
<li>适用于偏理解的NLP任务。</li>
<li>长文本生成任务差，训练效率低。</li>
</ul>
</li>
<li>Causal Decoder：<ul>
<li>GPT为代表，使用<strong>单向注意力掩码</strong>，每个token只能看到前面的token和本身，输入输出只有解码器以<strong>相同方式</strong>处理。</li>
<li>适用于文本生成任务。</li>
<li>训练效率高，zero-shot能力强，具有涌现能力。</li>
</ul>
</li>
<li>Prefix Decoder：<ul>
<li>GLM为代表，参考编解码器架构，前缀解码器对输入进行<strong>双向注意力</strong>编码，对输出则使用<strong>单向注意力掩码</strong>（token只知道前面的token）进行自回归预测。</li>
<li>适用于文本生成任务。</li>
</ul>
</li>
</ul>
<h1 id="🔥LLMs常见的预训练任务"><a href="#🔥LLMs常见的预训练任务" class="headerlink" title="🔥LLMs常见的预训练任务"></a>🔥LLMs常见的预训练任务</h1><ul>
<li>语言建模（LM）：<ul>
<li>根据给定序列<strong>预测下一个词元</strong>，使用似然函数进行优化。可以视为一种多任务学习。</li>
<li>比如在“这部电影剧情饱满，演员表演也很棒，非常好看”的预测中，“好看”就是模型<strong>对情感进行分析</strong>；对于“小明有三块糖，给了小红两块，还剩下一块”，“一块”就是<strong>对数学算术进行学习</strong>。这样的例子还有很多。</li>
<li>训练效率：Prefix Decoder &lt; Causal Decoder，后者在所有token上计算损失，前者仅在输出上算损失。</li>
</ul>
</li>
<li>去噪自编码（DAE）：<ul>
<li>在BERT中是经典的一个方法，对输入文本进行一系列<strong>随机替换</strong>或<strong>删除</strong>操作，形成“损坏”的文本，模型就需要恢复出被替换或删除的词元片段。</li>
<li>比语言建模更复杂，需要额外的优化策略，如替换词元的策略、替换片段长度、替换的比例等，会影响训练效果。</li>
</ul>
</li>
<li>混合去噪器（MoD）：<ul>
<li>结合语言建模和去噪自编码，把两者视为不同类型的去噪任务，进行统一建模。</li>
</ul>
</li>
</ul>
<h1 id="🔥LLMs的涌现能力与scaling-law"><a href="#🔥LLMs的涌现能力与scaling-law" class="headerlink" title="🔥LLMs的涌现能力与scaling law"></a>🔥LLMs的涌现能力与scaling law</h1><p>涌现能力：当一个复杂系统由很多微小个体构成，这些微小的个体凑在一起，相互作用，当数量足够多时，就可以在宏观层面展现出微观个体无法解释的特殊现象，类似“量变引起质变”。<br><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B6%8C%E7%8E%B0%E7%8E%B0%E8%B1%A1%E4%B8%8Escaling_law%E7%8E%B0%E8%B1%A1.jpg" alt="涌现现象与scaling law现象"><br>为什么LLMs会有涌现能力：</p>
<ul>
<li><strong>任务评价指标不够平滑</strong>，如上图左，就可以对于精确匹配任务（输出答案和真实答案需要完全一致）的严格要求，大模型就容易出现涌现现象，分数随着参量突然猛增。像右图一样使用多选题进行训练就可以避免这种情况，训练分数逐步上涨。</li>
<li><strong>复杂任务和子任务</strong>，一个最终任务比较复杂，而它又由多个符合scaling law的子任务组成，最终任务体现为涌现。就像下国际象棋，需要多个合法且正确的移动才能完成“将死”对方的最终任务。</li>
</ul>
<h2 id="✨OpenAI对于scaling-law的观点"><a href="#✨OpenAI对于scaling-law的观点" class="headerlink" title="✨OpenAI对于scaling law的观点"></a>✨OpenAI对于scaling law的观点</h2><ul>
<li>scaling law：用计算量、数据集规模和模型规模，来预测模型最终能力。</li>
<li>当计算量、数据集规模、模型规模（参数量）三者中任意两个固定时，剩下的那个因素随指数增长，loss会线性下降。所以为了获得最佳性能，应该同时扩大三者。</li>
<li>三者的影响程度是 计算量&gt;参数量&gt;&gt;数据集规模。</li>
<li>固定计算预算下训练时，最佳性能可以通过训练参数量非常大的模型并在远离收敛前停止（早停）实现。更大的模型在样本效率方面更好，能以更少的优化步骤和使用更少数据量达到相同水平，<strong>实际应用应优先考虑大的模型</strong>。</li>
</ul>
<h2 id="✨DeepMind对于scaling-law的观点"><a href="#✨DeepMind对于scaling-law的观点" class="headerlink" title="✨DeepMind对于scaling law的观点"></a>✨DeepMind对于scaling law的观点</h2><ul>
<li>该团队认为模型大小和训练数据量都应该<strong>按相等的比例扩展</strong>。</li>
</ul>
<ol>
<li>给定FLOP预算（算力），损失函数有明显低谷值，即数据量和模型规模的选择<strong>有一个最优解</strong>。</li>
<li>计算成本最优的情况下（第1点），模型大小和训练数据量应等比值地缩放。</li>
<li>大模型训练应该更关注数据集扩展，数据高质量时，更大数据集的好处才能体现。</li>
</ol>
<h1 id="🔥幻觉"><a href="#🔥幻觉" class="headerlink" title="🔥幻觉"></a>🔥幻觉</h1><p>即一本正经地胡说八道，不符合一致性（符合用户问题要求）和真实性（符合世界知识）。</p>
<h2 id="✨为什么有幻觉"><a href="#✨为什么有幻觉" class="headerlink" title="✨为什么有幻觉"></a>✨为什么有幻觉</h2><ol>
<li>数据角度：训练数据可信度有问题，或者过多重复信息会导致模型有偏见，从而导致幻觉。</li>
<li>模型角度：<ul>
<li>模型结构，比较弱的主干会导致幻觉，LLMs一般不存在该问题。</li>
<li>解码算法，如果使用不确定性高的采样算法（更容易生成多样化文本），可能会诱导LLMs出现幻觉。</li>
<li>暴露偏差：训练和测试阶段不匹配，特别是生成长文本回复的时候。</li>
<li>参数知识：LLMs在预训练阶段记忆了错误的知识，导致幻觉。</li>
</ul>
</li>
</ol>
<h2 id="✨如何评估幻觉"><a href="#✨如何评估幻觉" class="headerlink" title="✨如何评估幻觉"></a>✨如何评估幻觉</h2><p>分为基于参考的评估和无参考的评估。</p>
<ol>
<li><strong>基于参考文本</strong>：<ul>
<li>使用参考文本或原始信息进行对比，常用指标包括ROUGE、BLEU等。</li>
<li>适用于标准化生成任务，但对于参考答案不唯一的情况灵活性就受限。</li>
</ul>
</li>
<li><strong>无参考</strong>：<ul>
<li>不使用参考答案。</li>
<li>基于信息抽取（IE）：将生成内容转为结构化知识，也就是转为三元组之类的形式后给专门的模型去评估准确性。</li>
<li>基于问答（QA）：使用问题生成模型生成QA对，然后让被测模型回答这些问题，比较两个答案即可判断。</li>
<li>基于自然语言推理（NLI）：判断生成内容是否与源信息有蕴含关系。</li>
<li>基于事实性分类指标：通过人工标注或构造包含幻觉和真实信息的数据集，训练分类模型检测LLMs生成的文本是否符合事实。</li>
<li>人工评估：最准，但最贵。</li>
</ul>
</li>
</ol>
<h2 id="✨如何缓解幻觉"><a href="#✨如何缓解幻觉" class="headerlink" title="✨如何缓解幻觉"></a>✨如何缓解幻觉</h2><ol>
<li><strong>构建高质量数据集</strong>：人工标注、自动筛选等方法。</li>
<li>模型层面：<strong>模型结构</strong>上编码更多信息、减少生成随机性、检索增强（引入外部源，联网等）；<strong>训练方式</strong>上可控文本生成、提前规划内容框架、强化学习、多任务学习、后处理等都可以抑制幻觉。</li>
</ol>
<h1 id="🔥RAG"><a href="#🔥RAG" class="headerlink" title="🔥RAG"></a>🔥RAG</h1><h2 id="✨RAG介绍"><a href="#✨RAG介绍" class="headerlink" title="✨RAG介绍"></a>✨RAG介绍</h2><p>RAG（Retrieval Augmented Generation）：作用类似搜索引擎，找到用户提问最相关的知识或对话历史，结合原始提问，创造丰富的prompt，指导模型生成准确输出。本质上是情境学习。</p>
<ul>
<li>通俗来说：<strong>RAG（检索增强生成）&#x3D; 检索技术 + LLM提示</strong></li>
<li>RAG的特点：<ol>
<li>依赖大语言模型强化信息检索和输出：单独使用RAG能力会受限，它依赖LLM来进行检索和生成。</li>
<li>与外部数据有效集成：很好地接入和利用外部数据库的资源，弥补大模型对于某个专业领域知识的不足。</li>
<li>数据隐私和安全保障：可以使用私有数据库与模型链接。</li>
<li>表现效果受多方面因素影响而异：如LLM性能、接入数据质量、检索系统本身等。</li>
</ol>
</li>
</ul>
<p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/RAG%E6%A1%86%E6%9E%B6.jpg" alt="RAG框架"></p>
<ul>
<li>RAG分为五个基本流程：知识文档准备，嵌入模型，向量数据库，查询检索，生成回答。</li>
<li>先将文本以文本块的形式输入<strong>嵌入模型</strong>（类似嵌入层的功能），嵌入模型会生成向量形式的数据库。</li>
<li>使用时，用户访问RAG，用户的问题被嵌入模型转为向量，系统从向量数据库检索相似信息，信息和用户向量结合成一个prompt提示输出给<strong>大模型</strong>再生成回答，回答也能被作为历史记录到记忆库。</li>
<li>可以看到RAG其实就是以大模型为核心的强化版搜索引擎，相当于有一个秘书为你管理对应的知识。也可以看到如果RAG没有大模型也是能搜索信息并返回的，但是少了大模型的理解整合，效果势必是有限的。</li>
</ul>
<h2 id="✨评价RAG的好坏"><a href="#✨评价RAG的好坏" class="headerlink" title="✨评价RAG的好坏"></a>✨评价RAG的好坏</h2><ol>
<li>检索环节的评估：<ul>
<li>MRR平均倒数排名：常用于衡量搜索引擎、推荐系统等根据查询返回多个结果中的相关性。MRR值越高就越好，说明最相关的结果最有可能出现在更前的位置，反之亦然。</li>
<li>Hits Rate命中率：前k项中包含正确信息项的比例。</li>
<li>NDCG：DCG的思想，即高关联度结果比一般关联度结果更影响最终指标得分，且高关联度结果排序越靠前，指标越高。</li>
</ul>
</li>
<li>生成环节的评估：<ul>
<li>非量化：相关性、完整性、正确性</li>
<li>量化 Rouge-L：用于评价文本生成质量的指标，常用于自动摘要、机器翻译、文本生成等任务。底层原理是通过<strong>最长公共子序列</strong>来计算生成文本和参考文本的相似性（参考文本来自于专家人工编写），通过统计二者重叠基本单元数（n元语法、词序列等）来评估效果。</li>
</ul>
</li>
</ol>
<h2 id="✨RAG的优化策略"><a href="#✨RAG的优化策略" class="headerlink" title="✨RAG的优化策略"></a>✨RAG的优化策略</h2><h3 id="知识文档准备阶段"><a href="#知识文档准备阶段" class="headerlink" title="知识文档准备阶段"></a>知识文档准备阶段</h3><ol>
<li>数据清洗：<ul>
<li>基本文本清理：格式规范、去除特殊字符、去除冗余信息。</li>
<li>实体解析：消除实体和术语的歧义以实现一致引用。如将“LLM”、“大语言模型”等标准化为统一术语。</li>
<li>文档划分：合理划分不同主题文档，如果人类不能很好判断那个文档可能与问题相关，那么系统也做不到。</li>
<li>数据增强：同义词、解释语句的增加来增强多样性。</li>
<li>用户反馈循环：基于用户反馈更新数据库，标记真实性。</li>
<li>时间敏感数据：常更新的数据，要删除或更新过期内容。</li>
</ul>
</li>
<li>分块处理：<ul>
<li>方块方法：<ul>
<li>固定大小块：简单直接，计算资源要求低；</li>
<li>按内容分块：按标点符号等分割，可以调NLTK等库；</li>
<li>递归分块：大多数情况<strong>推荐</strong>，由大到小递归地分割，直到子块大小合适；</li>
<li>从小到大分块：大小分块都保留并分级，存储空间大；</li>
<li>特殊结构分块：可以根据结构化内容专门分割（如Markdown、Latex、编程语言等文件）。</li>
</ul>
</li>
<li>分块大小：<ul>
<li>不同嵌入模型有其最佳的分块大小。</li>
<li>长文本（如书籍）适合大分块，短文本（如媒体帖子）适合小分块。</li>
<li>用户通常查询内容长且复杂就适合大分块，反之亦然。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="嵌入模型阶段"><a href="#嵌入模型阶段" class="headerlink" title="嵌入模型阶段"></a>嵌入模型阶段</h3><ul>
<li>嵌入模型：<ul>
<li>word2vec：基于词向量，将文本转化为向量表示，常用于文本分类、文本聚类等任务，但是没法理解一词多义，词向量完全静态。</li>
<li>BERT：一个词在不同语境下会有不同的词向量表示。</li>
<li>推荐hugging face推出的嵌入模型排行榜MTEB，直接拿合适的用比较好，微调太费劲。</li>
</ul>
</li>
</ul>
<h3 id="向量数据库阶段"><a href="#向量数据库阶段" class="headerlink" title="向量数据库阶段"></a>向量数据库阶段</h3><ul>
<li>元数据：某些向量数据库支持将向量与<strong>元数据</strong>关联，元数据就是如日期、标签、章节号等信息，相当于为向量添加tag，能有效提高检索效率。</li>
</ul>
<h3 id="查询索引阶段"><a href="#查询索引阶段" class="headerlink" title="查询索引阶段"></a>查询索引阶段</h3><p>1-2都是讲怎么索引，怎么搜索；3讲的是怎么转换查询；4是一些可调的参数；5是进阶的高级策略；6是对结果的排序进行优化。</p>
<ol>
<li>多级索引<ul>
<li>元数据无法区分不同上下文类型的情况下，可以使用多重索引技术。</li>
<li>多重索引技术的核心是将庞大的数据按需求分类，在不同层级中组织，以实现更有效的关理和检索。</li>
<li>需要引入<strong>多级路由机制</strong>，如“最新上映的科幻电影”，RAG就会路由到专门处理热点话题的索引，然后在利用专注于娱乐、影视的索引来生成相关推荐。</li>
</ul>
</li>
<li>索引&#x2F;查询算法<ul>
<li>聚类：将向量点划分区域（簇），查询时只需要查询距离目标向量最接近的簇即可。<br><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BD%8D%E7%BD%AE%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C.jpg" alt="位置敏感哈希"></li>
<li>位置敏感哈希：传统哈希是key和value一一对应，而位置敏感哈希需要增加<strong>输出值碰撞的概率</strong>，哈希值相同的向量被分到同一个<strong>桶（bucket）</strong>当中，越相近的向量越可能被分到同一个桶。搜索时只需要获取目标向量的哈希值（key），找到对应桶进行二次搜索即可。</li>
<li>量化乘积：面对大数据的内存开销问题，希望削减数据的大小，比如在聚类的簇当中，用中心点表示整个簇的所有向量（虽然有区别但是损失可接受）。</li>
<li>分层导航小世界：类似六度分隔理论（认识任何一个陌生人最多经过6个人），构建一个图存储向量，查询时从某个点开始，查找其邻接节点中最接近目标向量的节点，然后对该节点也这么做，直到某节点周围节点不存在比它更接近目标的时候，就是我们要找的向量。</li>
</ul>
</li>
<li>查询转换<br>  也就是通过<strong>重写查询措辞</strong>来提升召回效果。<ul>
<li>结合历史对话进行重新表述：直接用LLM重新表述，或将历史对话信息和用户提问一起个LLM重新表述。</li>
<li>假设文档嵌入：让LLM在没有外部数据库的情况下对用户信息进行<strong>假设性回复</strong>，将该回复和提问一同用于检索。</li>
<li>退后提示：查询信息太复杂或者太宽泛，可以抽象为一个更简单的问题，然后和原始问题一起用于检索。</li>
<li>多查询检索&#x2F;多路召回：使用LLM生成多个搜索查询，适用于一个大问题蕴含多个子问题。</li>
</ul>
</li>
<li>检索参数<br>  可以根据向量库数据设置<strong>优化检索参数</strong>，也就是调参了。<ul>
<li>稀疏和稠密搜索权重：稠密搜索是用向量搜索，稀疏搜索是通过字符串关键字匹配进行搜索（稀有词通常作为关键词），通过<strong>设置权重</strong>结合两者搜索得分来返回检索内容。</li>
<li>结果数量topK：提供k个检索结果，确保覆盖用户查询要求的各个方面。</li>
<li>相似度度量：计算两个向量相似度（欧式距离、Jaccard距离、余弦相似度等），<strong>余弦相似度</strong>不受向量长度影响，比较好。</li>
</ul>
</li>
<li>高级检索策略<ul>
<li>上下文压缩：对<strong>长文档</strong>内容进行压缩，或者对返回结果过滤。</li>
<li>句子窗口搜索：将搜索到的<strong>太短分块</strong>周围的分块一并作为上下文给LLM，增强LLM理解。</li>
<li>父文档搜索：主文档分割为更短的子文档，用户问题会先匹配子文档，在将子文档的父文档和用户提问一起发给LLM。</li>
<li>自动合并：比父文档搜索更复杂，就是可以分成<strong>三层树状结</strong>构，搜索是匹配叶子结点，当某个父节点的多数叶子节点都匹配查询内容时就返回该父节点。</li>
<li>多向量检索：向量库存储信息格式是多向量而非单向量，<strong>额外包括</strong>了文档摘要、用户可能的问题等不同方面信息辅助检索。</li>
<li>多代理检索：结合之前提到的所有优化策略中的某几种，比如同时使用多向量检索和多级检索。</li>
<li>self-RAG：自反思搜索增强，通过检索评分和<strong>反思评分</strong>来提升质量。分为检索、生成、批评三个流程：<ul>
<li>先用检索评分来评估用户问题是否需要检索，若需要，LLM会调用检索模块查文档；</li>
<li>LLM接着分别为每个检索到的块生成答案；</li>
<li>再为每个答案生成反思评分评估检索到的文档是否相关；</li>
<li>最后将评分高的文档作为结果一并交给LLM进行生成。</li>
</ul>
</li>
</ul>
</li>
<li>重排模型<br>  通过对初始检索结果进行深入相关性评估和排序，确保展示给用户的结果更符合其意图。比如对于“最新科幻电影”的查询，可能返回科幻电影历史、最佳科幻电影、最新科幻电影等多种结果，模型需要对此分析并排序，把最新科幻电影放在前面。<ul>
<li><strong>RAG系统都应该尝试重排模型这个方法。</strong></li>
</ul>
</li>
</ol>
<h3 id="生成回答阶段"><a href="#生成回答阶段" class="headerlink" title="生成回答阶段"></a>生成回答阶段</h3><ol>
<li>提示词<ul>
<li>改变提示词形式可以有效影响模型对不同类型问题的接受程度和回答方式。</li>
<li>为减少幻觉和主观回答的可能性，<strong>RAG系统提示词中会强调回答仅基于搜索结果</strong></li>
<li>可以使用few-shot方法，也就是添加回答样例。</li>
<li>可以根据场景需要让模型的回答可以适当有主观成分和理解。</li>
</ul>
</li>
<li>大语言模型<ul>
<li>根据自己需求选择LLM，可以使用LangChain等常用开发框架来搭建RAG系统，它们提供了很好的debug工具。</li>
</ul>
</li>
</ol>
<h1 id="🔥知识蒸馏"><a href="#🔥知识蒸馏" class="headerlink" title="🔥知识蒸馏"></a>🔥知识蒸馏</h1><p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F.jpg" alt="知识蒸馏"><br>把大的教师模型的知识萃取出来，浓缩到一个小的学生模型。也就是<strong>用大模型教会小模型</strong>，实现轻量化。</p>
<h2 id="✨为什么进行知识蒸馏"><a href="#✨为什么进行知识蒸馏" class="headerlink" title="✨为什么进行知识蒸馏"></a>✨为什么进行知识蒸馏</h2><ul>
<li>提升模型精度：对某规模模型A不满意，可以训练精度更高的模型B，然后让这个模型B去训练原来这个小一点的A模型。</li>
<li>降低模型时延，压缩参数：对A模型时延不满意，可以找到时延更低参数更小的B模型，然后训练应该高精度的C模型对B模型进行知识蒸馏，使得B模型接近A。</li>
<li>标签之间的域迁移：用猫狗的数据集训练了教师模型A，使用水果训练了教师模型B，可以用俩模型同时蒸馏出一个同时识别猫狗和水果的模型。</li>
</ul>
<h2 id="✨传统知识蒸馏方法"><a href="#✨传统知识蒸馏方法" class="headerlink" title="✨传统知识蒸馏方法"></a>✨传统知识蒸馏方法</h2><p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E4%BC%A0%E7%BB%9F%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F%E6%96%B9%E6%B3%95.jpg" alt="传统知识蒸馏方法"></p>
<ol>
<li>基于<strong>反馈</strong>的知识蒸馏：<ul>
<li>关注教师模型最后一层的输出logits经过softmax之后，用作学生模型的标签，计算学生模型损失。</li>
<li>目标就是让学生模型输出的logits尽可能接近教师模型。</li>
</ul>
</li>
<li>基于<strong>特征</strong>的知识蒸馏：<ul>
<li>教师模型中间层的特征都用来作为监督标签训练学生模型。</li>
<li>这种方法中间层能够提供更丰富的信息，有助于更好地进行知识迁移。</li>
<li>难点就是消除架构不一致、目标层自动化选择等。</li>
</ul>
</li>
</ol>
<h2 id="✨大语言模型知识蒸馏方法"><a href="#✨大语言模型知识蒸馏方法" class="headerlink" title="✨大语言模型知识蒸馏方法"></a>✨大语言模型知识蒸馏方法</h2><p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F.jpg" alt="大语言模型知识蒸馏"></p>
<ul>
<li>就大模型权重是否可以获得分为<strong>白盒模型蒸馏</strong>和<strong>黑盒模型蒸馏</strong>，黑盒只能使用输出信息来训练小模型，而白盒可以获得模型权重来训练。</li>
<li>如图，基本流程从1-4就是通过指示大模型来获取种子知识（知识源），然后大模型生成知识给小模型训练。</li>
<li>图片上边可以看到，教师模型由多模态、代理、NLP等技能，可以用于各种领域（法律、医药、科学等）。</li>
<li>下方展示了教师模型如何利用数据进行驱动训练学生模型，包括生成标签、数据扩充、生数据处理、提取特征、反馈学生模型输出、学生模型自蒸馏等。</li>
<li>右边是蒸馏手段：<ul>
<li>教师模型监督微调学生模型。</li>
<li>教师模型输出指导学生模型的输出（提升相似性）。</li>
<li>强化学习：教师模型评估学生模型的输出反馈给学生模型。</li>
<li>排序优化：教师模型为学生模型多个输出进行排序，让学生模型知道什么是更好的输出。</li>
</ul>
</li>
</ul>
<h2 id="✨模型量化"><a href="#✨模型量化" class="headerlink" title="✨模型量化"></a>✨模型量化</h2><ul>
<li>目标是<strong>减小模型的存储需求和计算复杂度</strong>，就是可以在资源有限的设备上高效运行。</li>
<li>主要方式：<ul>
<li>更小的数据类型：32位FP转为16位FP、8位整数等。</li>
<li>模型压缩：霍夫曼编码（贪心算法，为频率高的符号编码更短）等算法。</li>
</ul>
</li>
<li>模型量化优势：减少存储空间、降低内存占用、加速推理。</li>
<li>挑战：精度损失、权衡效率和精度（性能不能太低）。</li>
</ul>
<h1 id="🔥模型压缩和加速的方法"><a href="#🔥模型压缩和加速的方法" class="headerlink" title="🔥模型压缩和加速的方法"></a>🔥模型压缩和加速的方法</h1><ol>
<li><strong>知识蒸馏</strong>：教师模型指导学生模型训练，提升小模型泛化能力和推理速度。</li>
<li><strong>参数剪枝</strong>：通过分析参数对性能的贡献，删除模型中冗余或贡献低的参数，以减少存储需求。</li>
<li><strong>网络剪枝</strong>：对神经网络删除冗余的神经元。</li>
<li><strong>蒸馏对抗网络</strong>：结合蒸馏和对抗训练方法，生成扰动样本，提升稳健性和抗干扰能力。</li>
<li><strong>层次化剪枝</strong>：针对每层对整体性能的影响，而设置不同的剪枝策略。</li>
<li><strong>低秩分解</strong>：将较大权重矩阵分解成几个小矩阵，减少参数量和计算开销，全连接层和卷积层常用。</li>
<li><strong>卷积分解</strong>：复杂卷积分解为简单的计算模块（深度可分离卷积），提升推理速度。</li>
</ol>
<h1 id="🔥微调"><a href="#🔥微调" class="headerlink" title="🔥微调"></a>🔥微调</h1><ul>
<li>大模型训练分为预训练、有监督微调、奖励建模、强化学习四个阶段。其中奖励模型是通过创建一个奖励模型评估生成结果的质量。</li>
<li>微调的目的是在预训练模型基础上针对特定任务进行优化模型性能。</li>
</ul>
<h2 id="✨什么时候微调"><a href="#✨什么时候微调" class="headerlink" title="✨什么时候微调"></a>✨什么时候微调</h2><ol>
<li>任务复杂度高，情境学习（仅使用prompt帮助模型理解）效果不足。</li>
<li>零样本（zero-shot）和少样本（few-shot）推理不佳。</li>
<li>领域或任务需求要求高度专业化，如法律、医学、工程等。</li>
<li>输出结果不符合用户要求，风格、格式不匹配，或者有个性化需求。</li>
</ol>
<h2 id="✨微调的方法"><a href="#✨微调的方法" class="headerlink" title="✨微调的方法"></a>✨微调的方法</h2><ul>
<li>针对<strong>参数</strong>，微调分为全量微调（FFT，调所有参数）和参数高效微调（PEFT，调少量或额外参数）。</li>
<li>全量微调会损失多样性，导致灾难性遗忘，所以通常LLM领域研究的都是参数高效微调。</li>
<li><strong>策略</strong>方面，分为有监督微调（SFT）和基于人类反馈的强化学习（RLHF），都可以用于全量或者参数高效微调。<ul>
<li>SFT：适用于有大量高质量标注数据集的场景，相当于有标准答案复习。主要用到调超参数、迁移学习、多任务学习、少样本学习、任务特定微调等。</li>
<li>RLHF：需要模型输出符合人类主观判断的结果，相当于在厨师指导下做菜。主要用到奖励建模、邻近策略优化PPO、比较排名、偏好学习、参数高效微调等，大部分方法都是基于人类主观设定。</li>
</ul>
</li>
</ul>
<p><strong>接下来主要介绍参数高效微调方法</strong></p>
<ul>
<li>主流分为Adapter、Prefix和LoRA三大类。</li>
<li>这些参数高效微调方法核心思想大部分都是<strong>为模型额外添加参数</strong>，相当于让没有兵种的士兵拿上武器成为特定兵种。</li>
</ul>
<p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%82%E6%95%B0%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83.jpg" alt="参数高效微调"></p>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>通过在预训练模型的各个多头注意力层之间添加一个Adapter层（适配器），只需要训练这个Adapter就行。</p>
<ul>
<li>每增加新的下游任务，就多一个adapter模块，其<strong>参数量很少</strong>，但是效果可以媲美全量微调（Fine-Tuning），又避免灾难性遗忘。</li>
<li>adapter fusion：通过将适配器训练分为知识提取和知识组合两个部分，解决遗忘和不稳定问题。</li>
<li>adapter drop：较低的transformer层删除可变数量的adapter来提升推理速度。</li>
</ul>
<h3 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h3><p>在QKV计算里面加参数，即为模型的输入<strong>添加k个额外的标记</strong>，训练这些额外的前缀参数就可以。<br><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Prefix_Tuning.jpg" alt="Prefix Tuning"></p>
<ul>
<li><strong>Prefix Tuning</strong>：如上图，对输入token之前构造和任务相关的虚拟tokens作为prefix，训练时只更新前缀部分，其他参数固定。<ul>
<li>该方法与Fine-Tuning效果比肩。</li>
</ul>
</li>
</ul>
<p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Prompt_Tuning.jpg" alt="Prompt Tuning"></p>
<ul>
<li><strong>Prompt Tuning</strong>：简化prefix tuning，对每个任务定义对应的离散化prompt，然后拼接到数据作为输入，这样可以让预训练模型做混合任务推理。<ul>
<li>该方法仅在输入层添加参数，而不用像prefix tuning那样每层都添加参数。</li>
<li>相较于prefix tuning，训练效率高，适合分类任务，在大尺寸模型与Fine-Tuning比肩。</li>
</ul>
</li>
</ul>
<p><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/P-Tuning.jpg" alt="P-Tuning"></p>
<ul>
<li><p><strong>P-Tuning</strong>：设计连续可微的虚拟token，即把prompt转化为可学习的embedding层，也是仅输入层加。</p>
<ul>
<li>虚拟token插入位置可以不一定是前缀，该方法在大尺寸模型与Fine-Tuning比肩。</li>
</ul>
</li>
<li><p><strong>P-Tuning V2</strong>：基于prompt Tuning、P-Tuning改进，每层都加Prompt tokens，提升了可学习参数量，为更深层的网络带来影响。</p>
<ul>
<li>不同任务prompt长度可以不一样，该方法能够在大、小尺寸模型都能与Fine-Tuning比肩。</li>
</ul>
</li>
</ul>
<h3 id="LoRA"><a href="#LoRA" class="headerlink" title="LoRA"></a>LoRA</h3><p>在多头矩阵运算上添加LoRA矩阵，学习<strong>小参数的低秩矩阵</strong>来近似模型权重矩阵w的参数更新，微调时只需要更新该矩阵来代替原参数矩阵更新。<br><img src="/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/LoRA%E5%BE%AE%E8%B0%83.jpg" alt="LoRA微调"></p>
<ul>
<li>如上图，可能在所示的transformer基本结构的<strong>两个位置</strong>添加LoRA模块进行<strong>前馈旁路</strong>输入。</li>
<li><strong>核心</strong>：LoRA结构为图中右边所示，权重更新用<code>W=W0+ΔW</code>表示，将权重矩阵变化量ΔW分解为低秩矩阵A（降维）、B（升维）来近似更新参数矩阵W，微调时W0不更新，仅和A、B分支输出进行合并。<blockquote>
<p>低秩代表用更少的参数就可以表示矩阵，秩少参数就少。 </p>
</blockquote>
</li>
<li>该方法相当于用更小的参数量进行更新，真正使用时LoRA结构也会被整合到模型，<strong>减少训练计算开销并且不增加实时推理开销</strong>。</li>
<li><strong>初始化</strong>：降维矩阵A用<strong>高斯分布</strong>初始化以添加随机性，升维矩阵B<strong>初始化为0</strong>，在训练开始时不影响输出。两者初始化方式理论上可以对调，如果都随机初始化会不稳定，都初始为0就收敛太慢了。</li>
<li><strong>可插拔任务切换</strong>：不同任务训练不同的A、B，随时可以切换。</li>
<li>LoRA可以作用在Q、K、V，并且同时作用效果好于单独作用。</li>
<li><strong>在已有LoRA上训练新任务</strong>：任务相似则直接当前LoRA模型上训练；任务不同但相关，可以把当前的LoRA融入基础模型，然后训练新的LoRA；任务完全不同就从原有基础模型开始训练，抛弃现有LoRA参数。</li>
<li><strong>避免过拟合</strong>：减小秩的值、增加数据集大小、增加优化器衰减权重（weight decay）、增加LoRA模块的dropout值，其实很多都是深度学习中用到的常见手段。</li>
<li>变体：<ul>
<li>AdaLoRA：根据重要性评分（一种损失）来动态地分配参数预算给权重矩阵，重要的增量矩阵分配高秩（更多参数），不重要的给低秩防止过拟合。</li>
<li>QLoRA：更轻量的LoRA，4位量化LLM，然后用LoRA方法对量化后的LLM进行微调，这样节约33%GPU内存，但是增加39%训练时间（量化压缩需要时间计算）。</li>
</ul>
</li>
</ul>
<h2 id="✨多轮对话如何微调"><a href="#✨多轮对话如何微调" class="headerlink" title="✨多轮对话如何微调"></a>✨多轮对话如何微调</h2><ol>
<li>数据准备：收集和创建适用于多轮对话的数据集<ul>
<li>方法：收集现有数据集、创建自定义数据集（专业性或特定需求）、数据清洗和预处理。</li>
<li>注意：上下文信息要有，数据要有多样性（话题、风格、情感等）。</li>
</ul>
</li>
<li>构建输入输出格式：将原始对话转为合适模型训练的格式<ul>
<li>方法：输入方面将<strong>已有对话拼成序列</strong>（如下），输出就是本轮要生成的内容。</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>用户<span class="token punctuation">]</span> 你好！
<span class="token punctuation">[</span>机器人<span class="token punctuation">]</span> 你好，请问有什么可以帮您的吗？
<span class="token punctuation">[</span>用户<span class="token punctuation">]</span> 我想预定一张去北京的火车票。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li>模型选择：<ul>
<li>常用：DialoGPT、Llama、BERT。</li>
<li>考虑：任务类型、模型大小、预训练数据量。</li>
</ul>
</li>
<li>微调模型：<ul>
<li>流程：初始化参数、定义损失函数、反向传播和参数更新、重复迭代，就是常规深度学习的流程。</li>
<li>注意：学习率设定、梯度剪裁等。</li>
</ul>
</li>
<li>超参数调优：优化模型的训练过程，提升性能<ul>
<li>可调参数：学习率、批次大小、训练轮数、权重衰减等。</li>
<li>常见方法：网格搜索（参数范围内遍历所有组合）、随机搜索（随机采样组合）、贝叶斯优化（贝叶斯理论智能搜索）。</li>
<li>评估：验证集表现、早停。</li>
</ul>
</li>
<li>评估（验证）和测试：评估分为<strong>自动和人工评估</strong>。<ul>
<li>自动评估：BLEU、ROUGE、Perplexity（困惑度）、Distinct-N（评估回复多样性）。</li>
<li>人工评估：流畅性、相关性、连贯性、信息性。</li>
<li>错误分析：看哪一类对话表现差、深入分析错误案例。</li>
</ul>
</li>
<li>特定技巧：<ul>
<li>对话策略：策略建模（让模型何时提供信息、引导对话等）、强化学习。</li>
<li>数据增强：同义替换、随机插入或删除、翻译回译（翻译回去）。</li>
<li>情感和个性化建模：标注情感、为模型设定人格。</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://legendleochen.top/2024/12/27/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LLM/" rel="tag">LLM</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/01/01/%E5%9F%BA%E4%BA%8EDQN%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%87%AA%E5%8A%A8%E8%B5%B0%E8%BF%B7%E5%AE%AB%EF%BC%882%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            基于DQN的机器人自动走迷宫（2）
          
        </div>
      </a>
    
    
      <a href="/2024/11/16/ROS2-ardupilot-mavros%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BB%BF%E7%9C%9F%E5%88%9D%E6%AD%A5/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">ROS2+ardupilot+mavros无人机仿真初步</div>
      </a>
    
  </nav>

  
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> LegendLeo Chen
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/mylogo.png" alt="LegendLeo Chen 的空间"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">🚀主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">💾归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">🧭分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">🏷️标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">🛸关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/analytics">📊统计</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=1491212&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
  <!-- 背景气泡 -->
  <!--
  <div class="balls-container">
    <div class="balls-particles">
      <span style="--i:11;"></span>
      <span style="--i:12;"></span>
      <span style="--i:24;"></span>
      <span style="--i:10;"></span>
      <span style="--i:14;"></span>
      <span style="--i:23;"></span>
      <span style="--i:18;"></span>
      <span style="--i:16;"></span>
      <span style="--i:19;"></span>
      <span style="--i:20;"></span>
      <span style="--i:22;"></span>
      <span style="--i:25;"></span>
      <span style="--i:18;"></span>
      <span style="--i:21;"></span>
      <span style="--i:13;"></span>
      <span style="--i:15;"></span>
      <span style="--i:26;"></span>
      <span style="--i:17;"></span>
      <span style="--i:13;"></span>
      <span style="--i:26;"></span>
      <span style="--i:28;"></span>
      <span style="--i:11;"></span>
      <span style="--i:12;"></span>
      <span style="--i:24;"></span>
      <span style="--i:10;"></span>
      <span style="--i:14;"></span>
      <span style="--i:23;"></span>
      <span style="--i:18;"></span>
      <span style="--i:16;"></span>
      <span style="--i:19;"></span>
      <span style="--i:20;"></span>
      <span style="--i:22;"></span>
      <span style="--i:25;"></span>
      <span style="--i:18;"></span>
      <span style="--i:21;"></span>
      <span style="--i:13;"></span>
      <span style="--i:15;"></span>
      <span style="--i:26;"></span>
      <span style="--i:17;"></span>
      <span style="--i:13;"></span>
      <span style="--i:26;"></span>
      <span style="--i:28;"></span>
    </div>
  </div>
  <style>
    *
    {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    .balls-container
    { 
      position: fixed;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      opacity: 0.3;
    }
    
    .balls-particles
    {
      position: fixed;
      display: flex;
      z-index: 3;
      padding: 0 20px;
    }
    
    .balls-particles span
    {
      position: relative;
      bottom: 30px;
      width: 30px;
      height: 30px;
      background-color: #4fc3dc;
      box-shadow: 0 0 0 10px #4fc3dc44,
      0 0 50px #4fc3dc,
      -100px 0 #4fc3dc99,
      100px 0 #ff2d7599;
      margin: 0 4px;
      border-radius: 50%;
      animation: animate 15s ease infinite;
      animation-delay: calc(125s / var(--i));
      transform: translateY(120vh);
    }
    .balls-particles span:nth-child(even) {
      background-color: #ff2d75;
      box-shadow: 0 0 0 10px #ff267544,
      0 0 50px #ff2d75,
      -100px 0 #4fc3dc99,
      100px 0 #4fc3dc99;
      ;
    }
    
    @keyframes animate {
      0%
      {
        transform: translateY(120vh) scale(0) rotate(0deg);
      }
      20%
      {
        transform: translateY(100vh) scale(1) rotate(0deg);
      }
      100%
      {
        transform: translateY(-50vh) scale(0.5) rotate(360deg);
      }
    }
  </style> -->
  <!-- 地月系统 -->
  <!-- <div class="earth-container" >
    <div class="planet"></div>
    <div class="satellite"></div>
   </div>
   <style>
    *{
      padding: 0;
      margin: 0;
      }
      .earth-container {
        width: 36.25em;
        height: 36.25em;
        position: absolute;
        top:5%;
        left: 93%;
        transform: translate(-50%, -50%);
        opacity: 0.3;
      }
      
      .planet{
        width: 15.62*3em;
        height: 15.62*3em;
        background-color: #02c0f5;
        border-radius: 50%;
        position: absolute;
        margin: auto;
        top:0;
        right: 0;
        bottom: 0;
        left: 0;
        z-index: 1;
      }
      
      .planet::before{
        content: '';
        width: 4em;
        height: 4em;
        background-color: #008fd6;
        position: absolute;
        top:10em;
        left: 8em;
        border-radius: 50%; 
        box-shadow: 15em 15em 0 2em #00d68b, 5em 8em 0 3em #10ade1;
      }
      
      .satellite{
        width: 5em;
        height: 5em;
        background-color: #dee517;
        border-radius: 50%;
        position: relative;
        left: -5em;
        bottom: -30em;
        animation: spin 5s infinite;
        z-index: 1;
      }
      
      @keyframes spin {
        49%{
          z-index: 1;
        }
        50%{
          bottom: 3em;
          left: 35em;
          z-index: -1;
        }
        100%{
          z-index: -1;
        }
      }
    </style> -->
<!-- 三角彩带背景 -->
  <canvas id="evanyou-canvas" style="opacity: 0.3; position: fixed; top: 0px; left: 0px; z-index: -1; width: 100%; height: 100%; pointer-events: none;"></canvas>
  <script src="https://cdn.jsdelivr.net/gh/XXXZhy/Blog_Image/js/evanyou_canvas.js"></script>
</body>

</html>